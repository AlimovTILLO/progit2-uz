[[_undoing]]
=== Ўзгаришларни бекор қилиш

Ихтиёрий босқичда ниманидир бекор қилиш зарурати пайдо бўлиши мумкин. Бу ерда биз киритилган ўзгаришларни бекор қилишниниг асосий бир нечта ускуналарини кўриб ўтамиз. 
Эҳтиёт бўлинг, ҳар доим ҳам бекор қилишларни бекор қилиб бўлмайди. 

Бу Git даги ниманидир нотўғри бажарсангиз маълумотларингизни йўқотиб қўйишингиз мумкин бўлган ўзи кўп бўлмаган жойлардан бири. 

Кўп такрорланадиган бекор қилишни асосан бирор файлни қўшишни унутиб ёки бошқача изоҳ киритиб фиксирлашни бажарганингизда амалга оширишингизга тўғри келади. Агар сизга ушбу фиксирлашни яна бир бор амалга ошириш керак бўлса, у ҳолда commit командасини `--amend` параметри билан беришингиз мумкин бўлади:

[source,console]
----
$ git commit --amend
----

Ушбу команда индексни олиб, уни фиксирлаш учун ишлатади. Агар охирги фиксирлашдан сўнг ҳеч қандай ўзгаришлар бўлмаган бўлса (масалан, сиз келтирилган командани бирданига олдингисидан сўнг ишга туширган бўлсангиз), у ҳолда лойиҳа ҳолати командада киритганингиздек бўлади. 

Фиксирлашларнинг шарҳлари учун яна ўша таҳрирловчи ойна пайдо бўлади, лекин энди охирги фиксирлашга шарҳ киритилган ҳолатда. Сиз ушбу шарҳни одатдагидай таҳрирлашингиз мумкин ва у аввалгисини ўрнига ёзилади.

Мисол учун, агар сиз ушбу фиксирлашга қўшилиши керак бўлган файлдаги ўзгаришларни индекслашни унутганингизни сезган бўлсангиз, у ҳолда сиз қуйидаги каби йўл тутишингиз мумкин:

[source,console]
----
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
----

Учта команда биргаликда битта фиксирлашни беради. Иккинчи фиксирлаш биринчи фиксирлашни натижасини алмаштиради.

[[_unstaging]]
==== Файлларни индекслашни бекор қилиш

Навбатдаги икки бўлимда биз қандай қилиб индексда ва ишчи каталогда ўзгариш киритишни намойиш этамиз. Ёқимлиси шуки, ушбу икки нарсани ҳолатини аниқлаш учун қўлланилувчи команда улардаги ўзгаришларни бекор қилиш ҳақидаги эслатмани ҳам кўрсатади. Мисол келтирамиз. Айтайлик, сиз иккита файлга ўзгариш киритдингиз ва уларни иккита алоҳида фиксирлаш тарзида ёзишни хоҳлаган эдингиз, бироқ адашиб `git add *` командасини териб иккала файлни ҳам индекслаб қўйдингиз.
Қандай қилиб энди икки файлдан бири учун индекслашни бекор қилиш мумкин?
`git status` командси сизга бу ҳақда эслатади:

[source,console]
----
$ git add .
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
----

``Changes to be committed'' ёзувидан кейин индексни олиб ташлаш учун `git reset HEAD <file>...` ни қўллаш кераклиги ёзиб қўйилган.
Шу сабабли келинг ушбу маслаҳатга амал қилган ҳолда `CONTRIBUTING.md` файлини индекслашдан олиб ташлаймиз:

[source,console]
----
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Ушбу команда бироз ғалатироқ бўлсада лекин у ишлаябди.
`CONTRIBUTING.md` файли ўзгартирилган бироқ энди у яна индексланмаганлар қаторида.

[NOTE]
=====
`git reset` командасини `--hard` билан биргаликда ишлатиш хавфли бўлиб, файл сизни ишчи каталогингизга тегишли бўлмай қолади. `git reset` командасини параметрсиз бериш хавфли эмас у фақат индексланганлар соҳаси билан ишлайди.
=====

Айни вақтда `git reset` командаси ҳақида билишингиз керак бўлганлари мана шулар. Би бу `reset` ҳақидаги қизиқарли батафсилроқ маълумотларни <<_git_reset>> да келтирамиз.

==== Файл ўзгаришини бекор қилиш

Агар сиз `CONTRIBUTING.md` файлидаги ўзгаришни қолдиришни хоҳламасангизчи?
Қандай қилиб ўзгаришни тез бекор қилиб уни ўзгаришдан олдинги охирги фиксирлашдаги ҳолатга (ёки бошланғич клонлаш бажарилган ёҳуд яна бир бошқа амал бажарилиб файлни ишчи каталогга тушган ҳолатига) келтириш мумкин?
Бахтимизга, `git status` командаси буни ҳам қандай қилиш мумкинлигини айтади.
Энг охирги мисолда чиқарилган натижада индексланмаган соҳа қуйидагича кўринади:

[source,console]
----
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Бу ерда қилинган ўзгаришларни қандай бекор қилиш кераклиги ҳақида етарли даражада айтилган.
Келинг нима деб ёзилган бўлса шуни қиламиз:

[source,console]
----
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

----

Сиз кўриб турганингиздек ўзгаришлар бекор қилинди.

[IMPORTANT]
=====
Сиз `git checkout -- [file]` команда хавфли эканлигини тушунишингиз керак: файлда қилган барча ўзгаришларингиз йўқ бўлиб кетди – сиз уни устига бошқа файлни нусҳаладингиз.
Ҳечқачон файл сизга керак эмаслигига тўлиқ ишонч хосил қилмасдан туриб, ушбу командани ишлатманг! 
=====

Агар уни сизга ҳалақит бермаслигини хоҳласангиз, биз яширишни (stash) ва тармоқланишни <<_git_branching>> бўлимда кўриб ўтамиз. Ушбу услублар кўпроқ мақтовга созовордир. 

Ёдда тутинг Git да нимаики фиксирлашни қисми бўлса деярли ҳар доим уни тиклаш мумкин.
Ҳатто бошқа тармоқда турган, ўчирилган ва `--amend` ёрдамида қайта ёзилган фиксирлашлар қайта тикланиши мумкин (маълумотларни тиклаш учун <<_data_recovery>> бўлимга қаранг). 
Бунга қарамасдан фиксирлашга киритилмаганларнинг барчасини энди қайта кўрмайсиз.
